<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail Scanner - Extract Sender Information</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="header-left">
                    <h1>Mail Scanner</h1>
                    <p class="subtitle">From your mailbox to theirs in minutes</p>
                </div>
                <div class="header-right">
                    <div class="account-menu-container">
                        <button class="account-menu-trigger" onclick="toggleAccountMenu(event)">
                            <svg style="width: 20px; height: 20px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                            <span class="account-email">{{ user.email }}</span>
                            <svg class="dropdown-arrow" style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                        <div class="account-dropdown" id="accountDropdown">
                            <a href="{{ url_for('account') }}" class="account-dropdown-item">
                                <svg style="width: 18px; height: 18px; margin-right: 10px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="3"></circle>
                                    <path d="M12 1v6m0 6v6m6-12l-6 6m0 0L6 7m12 12l-6-6m0 0l-6 6"></path>
                                </svg>
                                Account & Billing
                            </a>
                            <a href="{{ url_for('logout') }}" class="account-dropdown-item">
                                <svg style="width: 18px; height: 18px; margin-right: 10px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                    <polyline points="16 17 21 12 16 7"></polyline>
                                    <line x1="21" y1="12" x2="9" y2="12"></line>
                                </svg>
                                Logout
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tabs">
            <button id="scanTab" class="tab-button active" onclick="switchTab('scan')">
                Upload & Scan
            </button>
            <button id="resultsTab" class="tab-button" onclick="switchTab('results')">
                View Spreadsheet (<span id="tabResultCount">0</span>)
            </button>
        </nav>

        <main>
            <!-- Upload Section -->
            <section id="scanView" class="tab-content active">
            <section class="upload-section">
                <!-- Combined Input Methods -->
                <div class="input-methods">
                    <!-- Camera Button -->
                    <button id="openCameraBtn" class="btn btn-primary input-method-btn">
                        <svg style="width: 24px; height: 24px; margin-bottom: 8px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                            <circle cx="12" cy="13" r="4"></circle>
                        </svg>
                        <span>Take Photo</span>
                    </button>

                    <!-- Upload Button -->
                    <div class="upload-area input-method-btn" id="uploadArea">
                        <svg class="upload-icon" style="width: 24px; height: 24px; margin-bottom: 8px;" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <span>Drop or Browse Images</span>
                        <input type="file" id="fileInput" multiple accept="image/*,.heic,.heif" hidden>
                    </div>
                </div>

                <!-- Selected Files List -->
                <div id="selectedFiles" class="selected-files"></div>

                <!-- Main Scan Button -->
                <button id="scanAllButton" class="btn btn-primary btn-main" disabled>
                    Scan Photos
                </button>

                <!-- Secondary Controls -->
                <div class="scan-controls-secondary">
                    <button id="scanSelectedButton" class="btn btn-secondary btn-tiny" disabled>
                        Scan Selected
                    </button>
                    <button id="selectAllFilesButton" class="btn btn-secondary btn-tiny" disabled>
                        Select All
                    </button>
                    <button id="deselectAllFilesButton" class="btn btn-secondary btn-tiny" disabled>
                        Deselect All
                    </button>
                </div>
            </section>

            <!-- Progress Section -->
            <section id="progressSection" class="progress-section" style="display: none;">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill"></div>
                </div>
                <p id="progressText" class="progress-text">Processing...</p>
            </section>
            </section>

            <!-- Results Section (Separate Tab) -->
            <section id="resultsView" class="tab-content">
            <section id="resultsSection" class="results-section">
                <div class="results-header">
                    <h2>Scanned Results (<span id="resultCount">0</span>)</h2>
                    <div class="results-actions">
                        <button id="printPdfBtn" class="btn btn-primary" disabled>Print Selected (<span id="selectedCount">0</span>)</button>
                        <button id="exportCsvBtn" class="btn btn-success">Export to CSV</button>
                        <button id="exportExcelBtn" class="btn btn-success">Export to Excel</button>
                        <button id="clearBtn" class="btn btn-danger">Clear All</button>
                    </div>
                </div>

                <div class="filter-section" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                    <label for="categoryFilter" style="margin-right: 10px; font-weight: bold;">Filter by Category:</label>
                    <select id="categoryFilter" onchange="filterByCategory()" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="">All Categories</option>
                    </select>
                    <span id="filteredCount" style="margin-left: 15px; color: #666;"></span>
                </div>

                <div id="resultsTable" class="results-table">
                    <!-- Results will be inserted here -->
                </div>
            </section>
            </section>
        </main>

        <!-- Camera Modal -->
        <div id="cameraModal" class="camera-modal" style="display: none;">
            <div class="camera-modal-content">
                <div class="camera-header">
                    <h3>Take a Photo</h3>
                    <button id="closeCameraBtn" class="close-camera-btn">&times;</button>
                </div>
                <div class="camera-container">
                    <video id="cameraVideo" autoplay playsinline></video>
                    <canvas id="cameraCanvas" style="display: none;"></canvas>
                </div>
                <div class="camera-controls">
                    <button id="captureBtn" class="btn btn-primary">
                        <svg style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                        Capture Photo
                    </button>
                    <button id="autoCaptureBtn" class="btn btn-success" onclick="toggleAutoCapture()">
                        <svg style="width: 20px; height: 20px; vertical-align: middle; margin-right: 8px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Auto-Capture
                    </button>
                    <button id="switchCameraBtn" class="btn btn-secondary" style="display: none;">
                        <svg style="width: 20px; height: 20px; vertical-align: middle;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 2h2a2 2 0 0 1 2 2v2M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                        Switch Camera
                    </button>
                </div>
                <p class="camera-hint" id="cameraHint">Position the mail piece within the frame and tap Capture</p>
                <p class="camera-hint" id="autoHint" style="display: none; color: #4CAF50; font-weight: bold;">Auto-Capture Active - Hold steady on the address...</p>
            </div>
        </div>
    </div>

    <script>
        // State
        let selectedFiles = [];
        let results = [];
        let selectedResults = new Set();

        // Elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const scanSelectedButton = document.getElementById('scanSelectedButton');
        const scanAllButton = document.getElementById('scanAllButton');
        const selectAllFilesButton = document.getElementById('selectAllFilesButton');
        const deselectAllFilesButton = document.getElementById('deselectAllFilesButton');
        const selectedFilesDiv = document.getElementById('selectedFiles');
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const resultsSection = document.getElementById('resultsSection');
        const resultCount = document.getElementById('resultCount');
        const resultsTable = document.getElementById('resultsTable');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportExcelBtn = document.getElementById('exportExcelBtn');
        const clearBtn = document.getElementById('clearBtn');
        const printPdfBtn = document.getElementById('printPdfBtn');
        const selectedCount = document.getElementById('selectedCount');

        // Load existing results on page load
        loadResults();

        // Tab switching
        function switchTab(tab) {
            const scanTab = document.getElementById('scanTab');
            const resultsTab = document.getElementById('resultsTab');
            const scanView = document.getElementById('scanView');
            const resultsView = document.getElementById('resultsView');

            if (tab === 'scan') {
                scanTab.classList.add('active');
                resultsTab.classList.remove('active');
                scanView.classList.add('active');
                resultsView.classList.remove('active');
            } else {
                scanTab.classList.remove('active');
                resultsTab.classList.add('active');
                scanView.classList.remove('active');
                resultsView.classList.add('active');
            }
        }

        // Upload area click
        uploadArea.addEventListener('click', () => fileInput.click());

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
        });

        // Handle selected files
        function handleFiles(files) {
            const newFiles = files.filter(file => file.type.startsWith('image/'));

            if (newFiles.length === 0) {
                alert('Please select valid image files');
                return;
            }

            // Add unique ID to each file for tracking
            newFiles.forEach(file => {
                if (!file.uniqueId) {
                    file.uniqueId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    file.isChecked = true; // New files are checked by default
                }
            });

            // Accumulate files instead of replacing
            selectedFiles = [...selectedFiles, ...newFiles];

            displaySelectedFiles();
            updateButtonStates();

            // Reset file input so same file can be uploaded again if needed
            fileInput.value = '';
        }

        // Display selected files
        function displaySelectedFiles() {
            if (selectedFiles.length === 0) {
                selectedFilesDiv.innerHTML = '';
                return;
            }

            const checkedCount = selectedFiles.filter(f => f.isChecked).length;

            selectedFilesDiv.innerHTML = `
                <p><strong>${selectedFiles.length}</strong> file(s) ready to scan (<strong>${checkedCount}</strong> selected):</p>
                <ul class="file-list" style="list-style: none; padding: 0;">
                    ${selectedFiles.map(f => `
                        <li style="display: flex; align-items: center; padding: 5px 0; gap: 10px;">
                            <input type="checkbox"
                                   id="file_${f.uniqueId}"
                                   ${f.isChecked ? 'checked' : ''}
                                   onchange="toggleFileSelection('${f.uniqueId}')"
                                   style="cursor: pointer;">
                            <label for="file_${f.uniqueId}" style="flex: 1; cursor: pointer;">${f.name}</label>
                            <button class="btn btn-small btn-danger"
                                    onclick="removeFile('${f.uniqueId}')"
                                    style="padding: 2px 8px; font-size: 12px;">Remove</button>
                        </li>
                    `).join('')}
                </ul>
            `;
        }

        // File selection functions
        function toggleFileSelection(fileId) {
            const file = selectedFiles.find(f => f.uniqueId === fileId);
            if (file) {
                file.isChecked = !file.isChecked;
                displaySelectedFiles();
                updateButtonStates();
            }
        }

        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(f => f.uniqueId !== fileId);
            displaySelectedFiles();
            updateButtonStates();
        }

        function updateButtonStates() {
            const checkedCount = selectedFiles.filter(f => f.isChecked).length;
            const totalCount = selectedFiles.length;

            scanSelectedButton.disabled = checkedCount === 0;
            scanAllButton.disabled = totalCount === 0;
            selectAllFilesButton.disabled = totalCount === 0;
            deselectAllFilesButton.disabled = totalCount === 0;
        }

        // Select/Deselect all files
        selectAllFilesButton.addEventListener('click', () => {
            selectedFiles.forEach(f => f.isChecked = true);
            displaySelectedFiles();
            updateButtonStates();
        });

        deselectAllFilesButton.addEventListener('click', () => {
            selectedFiles.forEach(f => f.isChecked = false);
            displaySelectedFiles();
            updateButtonStates();
        });

        // Scan button clicks
        scanSelectedButton.addEventListener('click', () => uploadAndScan(false));
        scanAllButton.addEventListener('click', () => uploadAndScan(true));

        // Upload and scan
        async function uploadAndScan(scanAll = false) {
            if (selectedFiles.length === 0) return;

            // Determine which files to scan
            const filesToScan = scanAll ? selectedFiles : selectedFiles.filter(f => f.isChecked);

            if (filesToScan.length === 0) {
                alert('No files selected to scan');
                return;
            }

            scanSelectedButton.disabled = true;
            scanAllButton.disabled = true;
            progressSection.style.display = 'block';

            const fileCount = filesToScan.length;
            progressText.textContent = `Uploading ${fileCount} file${fileCount > 1 ? 's' : ''}... This may take a few minutes.`;
            progressBar.style.width = '30%';

            const formData = new FormData();
            filesToScan.forEach(file => {
                formData.append('files[]', file);
            });

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                // Check if response is OK before parsing JSON
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`Server error (${response.status}): ${text.substring(0, 200)}`);
                }

                const data = await response.json();

                // Check for authentication error
                if (response.status === 401 || data.error === 'Authentication required') {
                    alert('Your session has expired. Please log in again.');
                    window.location.href = data.redirect || '/login';
                    return;
                }

                if (data.success) {
                    progressBar.style.width = '100%';

                    let message = `Successfully scanned ${data.scanned_count} of ${data.total_files} photo${data.total_files > 1 ? 's' : ''}!`;
                    if (data.errors && data.errors.length > 0) {
                        message += ` (${data.errors.length} failed)`;
                    }
                    progressText.textContent = message;

                    // Load and display results
                    await loadResults();

                    // Remove scanned files from the list
                    const scannedFileIds = new Set(filesToScan.map(f => f.uniqueId));
                    selectedFiles = selectedFiles.filter(f => !scannedFileIds.has(f.uniqueId));

                    // Reset
                    setTimeout(() => {
                        progressSection.style.display = 'none';
                        progressBar.style.width = '0%';
                        displaySelectedFiles();
                        updateButtonStates();
                    }, 3000);

                    if (data.errors && data.errors.length > 0) {
                        alert('Some files had errors:\n' + data.errors.join('\n'));
                    }
                } else {
                    throw new Error(data.error || 'Upload failed');
                }
            } catch (error) {
                progressText.textContent = 'Error: ' + error.message;
                progressBar.style.width = '100%';
                progressBar.style.backgroundColor = '#dc3545';
                setTimeout(() => {
                    progressSection.style.display = 'none';
                    progressBar.style.width = '0%';
                    progressBar.style.backgroundColor = '#4CAF50';
                    updateButtonStates();
                }, 3000);
            }
        }

        // Load results from server
        async function loadResults() {
            try {
                const response = await fetch('/results');
                const data = await response.json();

                if (data.success) {
                    results = data.results;
                    displayResults();
                }
            } catch (error) {
                console.error('Error loading results:', error);
            }
        }

        // Display results
        function displayResults() {
            resultCount.textContent = results.length;
            document.getElementById('tabResultCount').textContent = results.length;

            if (results.length === 0) {
                resultsTable.innerHTML = '<p class="no-results">No results yet. Upload and scan some mail photos to get started!</p>';
                document.getElementById('categoryFilter').innerHTML = '<option value="">All Categories</option>';
                return;
            }

            // Populate category filter
            populateCategoryFilter();

            resultsTable.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAll" onchange="toggleSelectAll()"></th>
                            <th>File</th>
                            <th>Sender Name</th>
                            <th>Address</th>
                            <th>Verified</th>
                            <th>Category</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        ${results.map(result => {
                            // Determine which address to display
                            const hasVerified = result.verified && result.verified_full_address;
                            const displayAddress = hasVerified ? result.verified_full_address : result.full_address;
                            const showOriginal = hasVerified && result.full_address !== result.verified_full_address;

                            // Verification status badge
                            let verificationBadge = '';
                            if (result.verification_status === 'verified') {
                                verificationBadge = '<span style="color: #28a745; font-weight: bold;">✓ Verified</span>';
                            } else if (result.verification_status === 'verified_missing_secondary') {
                                verificationBadge = '<span style="color: #28a745; font-weight: bold;">✓ Verified</span><br><small style="color: #6c757d;">(missing unit #)</small>';
                            } else if (result.verification_status === 'unverified') {
                                verificationBadge = '<span style="color: #ffc107; font-weight: bold;">⚠ Unverified</span><br><small style="color: #6c757d;">(not in USPS DB)</small>';
                            } else if (result.verification_status === 'no_confirmation') {
                                verificationBadge = '<span style="color: #6c757d; font-weight: bold;">○ No Confirmation</span>';
                            } else if (result.verification_status === 'insufficient_data') {
                                verificationBadge = '<span style="color: #6c757d; font-weight: bold;">○ Incomplete</span>';
                            } else {
                                verificationBadge = '<span style="color: #dc3545; font-weight: bold;">✗ Failed</span>';
                            }

                            return `
                            <tr data-category="${result.category || ''}" data-id="${result.id}">
                                <td><input type="checkbox" class="result-checkbox" data-id="${result.id}" onchange="toggleResultSelection('${result.id}')"></td>
                                <td>${result.filename}</td>
                                <td>${result.sender_name || '<em>Not found</em>'}</td>
                                <td>
                                    ${displayAddress || '<em>Not found</em>'}
                                    ${showOriginal ? `<br><small style="color: #6c757d;">Original: ${result.full_address}</small>` : ''}
                                </td>
                                <td>${verificationBadge}</td>
                                <td><strong>${result.category || '<em>Not found</em>'}</strong></td>
                                <td>
                                    <button class="btn btn-small btn-danger" onclick="deleteResult('${result.id}')">Delete</button>
                                </td>
                            </tr>
                        `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            updateSelectedCount();
            filterByCategory(); // Apply any existing filter
        }

        // Populate category filter dropdown
        function populateCategoryFilter() {
            const categories = new Set();
            results.forEach(result => {
                if (result.category) {
                    categories.add(result.category);
                }
            });

            const categoryFilter = document.getElementById('categoryFilter');
            const currentValue = categoryFilter.value;

            categoryFilter.innerHTML = '<option value="">All Categories</option>';

            Array.from(categories).sort().forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });

            // Restore previous selection if it exists
            if (currentValue && Array.from(categories).includes(currentValue)) {
                categoryFilter.value = currentValue;
            }
        }

        // Filter results by category
        function filterByCategory() {
            const selectedCategory = document.getElementById('categoryFilter').value;
            const rows = document.querySelectorAll('#resultsTableBody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const rowCategory = row.dataset.category;
                if (!selectedCategory || rowCategory === selectedCategory) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                    // Uncheck hidden rows
                    const checkbox = row.querySelector('.result-checkbox');
                    if (checkbox && checkbox.checked) {
                        checkbox.checked = false;
                        selectedResults.delete(checkbox.dataset.id);
                    }
                }
            });

            // Update filtered count display
            const filteredCountSpan = document.getElementById('filteredCount');
            if (selectedCategory) {
                filteredCountSpan.textContent = `Showing ${visibleCount} of ${results.length}`;
            } else {
                filteredCountSpan.textContent = '';
            }

            // Update select all checkbox
            const selectAllCheckbox = document.getElementById('selectAll');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }

            updateSelectedCount();
        }

        // Delete result
        async function deleteResult(id) {
            if (!confirm('Delete this result?')) return;

            try {
                const response = await fetch(`/delete/${id}`);
                const data = await response.json();

                if (data.success) {
                    await loadResults();
                }
            } catch (error) {
                alert('Error deleting result: ' + error.message);
            }
        }

        // Export to CSV
        exportCsvBtn.addEventListener('click', () => {
            window.location.href = '/export/csv';
        });

        // Export to Excel
        exportExcelBtn.addEventListener('click', () => {
            window.location.href = '/export/excel';
        });

        // Clear all
        clearBtn.addEventListener('click', async () => {
            if (!confirm('Clear all results? This cannot be undone.')) return;

            try {
                const response = await fetch('/clear');
                const data = await response.json();

                if (data.success) {
                    await loadResults();
                }
            } catch (error) {
                alert('Error clearing results: ' + error.message);
            }
        });

        // Toggle select all
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAll');
            const rows = document.querySelectorAll('#resultsTableBody tr');

            selectedResults.clear();

            rows.forEach(row => {
                // Only select visible rows
                if (row.style.display !== 'none') {
                    const checkbox = row.querySelector('.result-checkbox');
                    if (checkbox) {
                        checkbox.checked = selectAllCheckbox.checked;
                        if (selectAllCheckbox.checked) {
                            selectedResults.add(checkbox.dataset.id);
                        }
                    }
                }
            });

            updateSelectedCount();
        }

        // Toggle individual result selection
        function toggleResultSelection(id) {
            if (selectedResults.has(id)) {
                selectedResults.delete(id);
            } else {
                selectedResults.add(id);
            }
            updateSelectedCount();
        }

        // Update selected count display
        function updateSelectedCount() {
            const count = selectedResults.size;
            selectedCount.textContent = count;
            printPdfBtn.disabled = count === 0;
        }

        // Print selected results to PDF
        printPdfBtn.addEventListener('click', async () => {
            if (selectedResults.size === 0) return;

            const ids = Array.from(selectedResults);
            const url = `/export/print-pdf?ids=${ids.join(',')}`;
            window.open(url, '_blank');
        });

        // ==================== CAMERA FUNCTIONALITY ====================

        // Camera elements
        const cameraModal = document.getElementById('cameraModal');
        const openCameraBtn = document.getElementById('openCameraBtn');
        const closeCameraBtn = document.getElementById('closeCameraBtn');
        const cameraVideo = document.getElementById('cameraVideo');
        const cameraCanvas = document.getElementById('cameraCanvas');
        const captureBtn = document.getElementById('captureBtn');
        const switchCameraBtn = document.getElementById('switchCameraBtn');

        let currentStream = null;
        let currentFacingMode = 'environment'; // Start with back camera on mobile
        let capturedPhotoCount = 0;
        let autoCaptureActive = false;
        let autoCaptureInterval = null;

        // Check if device has camera
        async function checkCameraSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                let message = 'Camera access is not supported.\n\n';

                // Check if it's an HTTPS issue
                if (window.location.protocol === 'http:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                    message += 'Camera access requires HTTPS (secure connection).\n\n';
                    message += 'To use the camera:\n';
                    message += '1. Access this site via HTTPS, or\n';
                    message += '2. Use the "Browse" button to upload photos\n\n';
                } else {
                    message += 'Your browser does not support camera access.\n\n';
                    message += 'Try using:\n';
                    message += '• Chrome or Safari on iOS\n';
                    message += '• Chrome or Firefox on Android\n';
                    message += '• Chrome, Firefox, or Edge on desktop\n\n';
                }

                message += 'You can still upload photos using the "Browse" button above.';
                alert(message);
                return false;
            }

            return true; // We'll check actual camera access when opening
        }

        // Enumerate cameras after getting permission
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                // Show switch camera button if multiple cameras available
                if (videoDevices.length > 1) {
                    switchCameraBtn.style.display = 'inline-block';
                } else {
                    switchCameraBtn.style.display = 'none';
                }

                return videoDevices.length > 0;
            } catch (error) {
                console.error('Error enumerating cameras:', error);
                return false;
            }
        }

        // Open camera
        async function openCamera() {
            const hasSupport = await checkCameraSupport();
            if (!hasSupport) return;

            try {
                // Stop any existing stream
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }

                // Request camera access with appropriate constraints
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraVideo.srcObject = currentStream;

                // Enumerate cameras after getting permission
                await enumerateCameras();

                // Show modal
                cameraModal.style.display = 'flex';
            } catch (error) {
                console.error('Error accessing camera:', error);

                let errorMessage = 'Could not access camera.\n\n';

                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Camera permission was denied. Please:\n1. Check your browser settings\n2. Allow camera access for this site\n3. Try again';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No camera found on this device.\n\nPlease use the "Browse" button to upload photos instead.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Camera is already in use by another application.\n\nPlease close other apps using the camera and try again.';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage += 'Camera does not meet the required specifications.\n\nTrying with default settings...';
                    // Retry with simpler constraints
                    try {
                        currentStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                        cameraVideo.srcObject = currentStream;
                        await enumerateCameras();
                        cameraModal.style.display = 'flex';
                        return;
                    } catch (retryError) {
                        errorMessage += '\n\nStill failed. Please use the "Browse" button instead.';
                    }
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'Camera is not supported in this browser.\n\nPlease use Chrome, Safari, or Firefox.';
                } else {
                    errorMessage += 'Error: ' + error.message + '\n\nPlease use the "Browse" button to upload photos instead.';
                }

                alert(errorMessage);
            }
        }

        // Toggle Auto-Capture
        function toggleAutoCapture() {
            autoCaptureActive = !autoCaptureActive;
            const autoCaptureBtn = document.getElementById('autoCaptureBtn');
            const cameraHint = document.getElementById('cameraHint');
            const autoHint = document.getElementById('autoHint');

            if (autoCaptureActive) {
                autoCaptureBtn.textContent = 'Stop Auto-Capture';
                autoCaptureBtn.classList.remove('btn-success');
                autoCaptureBtn.classList.add('btn-danger');
                cameraHint.style.display = 'none';
                autoHint.style.display = 'block';
                startAutoCapture();
            } else {
                autoCaptureBtn.textContent = 'Auto-Capture';
                autoCaptureBtn.classList.remove('btn-danger');
                autoCaptureBtn.classList.add('btn-success');
                cameraHint.style.display = 'block';
                autoHint.style.display = 'none';
                stopAutoCapture();
            }
        }

        // Start auto-capture detection
        function startAutoCapture() {
            // Check every 2 seconds
            autoCaptureInterval = setInterval(async () => {
                await checkForAddress();
            }, 2000);
        }

        // Stop auto-capture detection
        function stopAutoCapture() {
            if (autoCaptureInterval) {
                clearInterval(autoCaptureInterval);
                autoCaptureInterval = null;
            }
        }

        // Check if camera is showing a readable address
        async function checkForAddress() {
            try {
                // Capture current frame
                cameraCanvas.width = cameraVideo.videoWidth;
                cameraCanvas.height = cameraVideo.videoHeight;
                const context = cameraCanvas.getContext('2d');
                context.drawImage(cameraVideo, 0, 0);

                // Convert to blob
                const blob = await new Promise(resolve => {
                    cameraCanvas.toBlob(resolve, 'image/jpeg', 0.7);
                });

                // Send to backend for quick analysis
                const formData = new FormData();
                formData.append('frame', blob, 'frame.jpg');

                const response = await fetch('/check-address', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                // If address detected, auto-capture
                if (data.has_address) {
                    console.log('Address detected! Auto-capturing...');
                    stopAutoCapture();
                    autoCaptureActive = false;

                    // Reset button state
                    const autoCaptureBtn = document.getElementById('autoCaptureBtn');
                    autoCaptureBtn.textContent = 'Auto-Capture';
                    autoCaptureBtn.classList.remove('btn-danger');
                    autoCaptureBtn.classList.add('btn-success');
                    document.getElementById('cameraHint').style.display = 'block';
                    document.getElementById('autoHint').style.display = 'none';

                    // Capture the photo
                    capturePhoto();
                }
            } catch (error) {
                console.error('Error checking for address:', error);
            }
        }

        // Close camera
        function closeCamera() {
            stopAutoCapture(); // Stop auto-capture if active
            autoCaptureActive = false;

            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            cameraVideo.srcObject = null;
            cameraModal.style.display = 'none';

            // Reset button states
            const autoCaptureBtn = document.getElementById('autoCaptureBtn');
            autoCaptureBtn.textContent = 'Auto-Capture';
            autoCaptureBtn.classList.remove('btn-danger');
            autoCaptureBtn.classList.add('btn-success');
            document.getElementById('cameraHint').style.display = 'block';
            document.getElementById('autoHint').style.display = 'none';
        }

        // Switch camera (front/back)
        async function switchCamera() {
            currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';

            // Close current stream first
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }

            await openCamera();
        }

        // Capture photo
        function capturePhoto() {
            // Set canvas size to match video
            cameraCanvas.width = cameraVideo.videoWidth;
            cameraCanvas.height = cameraVideo.videoHeight;

            // Draw current video frame to canvas
            const context = cameraCanvas.getContext('2d');
            context.drawImage(cameraVideo, 0, 0);

            // Convert canvas to blob
            cameraCanvas.toBlob(async (blob) => {
                if (!blob) {
                    alert('Failed to capture photo');
                    return;
                }

                // Create a File object from the blob
                capturedPhotoCount++;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `camera-capture-${timestamp}.jpg`;
                const file = new File([blob], filename, { type: 'image/jpeg' });

                // Add unique ID for tracking
                file.uniqueId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                file.isChecked = true;

                // Add to selected files
                selectedFiles.push(file);

                // Update UI
                displaySelectedFiles();
                updateButtonStates();

                // Close camera and switch to scan view
                closeCamera();

                // Show success message
                alert(`Photo captured! Added to upload queue (${selectedFiles.length} total files)`);
            }, 'image/jpeg', 0.92);
        }

        // Event listeners for camera
        openCameraBtn.addEventListener('click', openCamera);
        closeCameraBtn.addEventListener('click', closeCamera);
        captureBtn.addEventListener('click', capturePhoto);
        switchCameraBtn.addEventListener('click', switchCamera);

        // Close modal when clicking outside
        cameraModal.addEventListener('click', (e) => {
            if (e.target === cameraModal) {
                closeCamera();
            }
        });

        // Cleanup camera stream when page unloads
        window.addEventListener('beforeunload', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        });

        // ==================== ACCOUNT MENU ====================

        function toggleAccountMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('accountDropdown');
            dropdown.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('accountDropdown');
            const container = document.querySelector('.account-menu-container');

            if (!container.contains(e.target)) {
                dropdown.classList.remove('show');
            }
        });
    </script>
</body>
</html>
